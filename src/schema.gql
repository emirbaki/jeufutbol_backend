# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Tenant {
  id: ID!
  name: String!
  subdomain: String!
  clientId: String
  users: [User!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type Insight {
  id: ID!
  userId: String!
  sourceTweetId: String
  type: InsightType!
  title: String!
  description: String!
  metadata: JSON
  relevanceScore: Float!
  isRead: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  sourceTweet: Tweet
  tenantId: String
}

"""Types of insights generated from analyzed tweets or profiles"""
enum InsightType {
  TRENDING_TOPIC
  CONTENT_SUGGESTION
  ENGAGEMENT_PATTERN
  OPTIMAL_POSTING_TIME
  AUDIENCE_INTEREST
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Tweet {
  id: ID!
  monitoredProfileId: String!
  tweetId: String!
  content: String!
  createdAt: DateTime!
  likes: Int!
  retweets: Int!
  replies: Int!
  views: Int!
  mediaUrls: [String!]
  hashtags: [String!]
  mentions: [String!]
  urls: [String!]

  """Raw tweet data (JSON as object)"""
  rawData: String
  isIndexedInVector: Boolean!
  fetchedAt: DateTime!
  monitoredProfile: MonitoredProfile!
  insights: [Insight!]
  tenantId: String
}

type MonitoredProfile {
  id: ID!
  userId: String!
  xUsername: String!
  xUserId: String!
  displayName: String
  followerCount: Int
  description: String
  profileImageUrl: String
  isActive: Boolean!
  lastFetchedAt: DateTime
  fetchMetadata: JSON
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User
  tenant: Tenant
}

type User {
  id: ID!
  email: String!
  isVerified: Boolean!
  firstName: String!
  lastName: String!
  isActive: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  posts: [Post!]
  monitoredProfiles: [MonitoredProfile!]
  tenant: Tenant
  role: UserRole!
}

enum UserRole {
  ADMIN
  MANAGER
  USER
}

type PublishedPost {
  id: ID!
  postId: String!
  platform: PlatformType!
  platformPostId: String!
  platformPostUrl: String!
  publishMetadata: JSON
  publishId: String
  publishStatus: String
  publishedAt: DateTime!
  post: Post!
  tenantId: String
}

"""Supported social media platforms for published posts"""
enum PlatformType {
  INSTAGRAM
  FACEBOOK
  X
  TIKTOK
  YOUTUBE
}

type Post {
  id: ID!
  userId: String!
  content: String!
  mediaUrls: [String!]
  platformSpecificContent: JSON
  status: PostStatus!
  targetPlatforms: [String!]!
  scheduledFor: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
  publishedPosts: [PublishedPost!]
  tenant: Tenant
  failureReasons: JSON
  tiktokSettings: JSON
}

"""PostStatus enum representing the status of a post"""
enum PostStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  FAILED
}

type Credential {
  id: ID!
  name: String!
  platform: String!
  type: String!
  userId: String!
  encryptedData: String!
  refreshToken: String
  accessToken: String
  accessSecret: String
  tokenExpiresAt: DateTime
  accountId: String
  accountName: String
  accountImage: String
  isActive: Boolean!
  metadata: String
  createdAt: DateTime!
  updatedAt: DateTime!
  tenantId: String
}

type TikTokCreatorInfo {
  creator_nickname: String!
  creator_avatar_url: String!
  privacy_level_options: [String!]!
  max_video_post_duration_sec: Int!
  comment_disabled: Boolean!
  duet_disabled: Boolean!
  stitch_disabled: Boolean!
}

type ApiKey {
  id: ID!
  name: String!
  keyPrefix: String!
  tenant: Tenant!
  createdBy: User
  scopes: [String!]!
  isActive: Boolean!
  lastUsedAt: DateTime
  expiresAt: DateTime
  metadata: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserInvitation {
  id: ID!
  email: String!
  tenant: Tenant!
  invitedBy: User!
  role: UserRole!
  token: String!
  status: InvitationStatus!
  expiresAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REVOKED
  EXPIRED
}

type AuthPayload {
  user: User!
  accessToken: String!
}

type MessageResponse {
  message: String!
}

type CreateApiKeyResponse {
  id: String!
  name: String!
  apiKey: String!
  keyPrefix: String!
  scopes: [String!]!
  expiresAt: DateTime
}

type JobIdResponse {
  jobId: String!
}

type BatchIndexResponse {
  jobIds: [String!]!
  profileCount: Float!
}

type ChatMessage {
  id: ID!
  sessionId: String!
  role: String!
  content: String!
  tokenUsage: JSON
  session: ChatSession!
  createdAt: DateTime!
}

type ChatSession {
  id: ID!
  userId: String!
  tenantId: String!
  title: String
  user: User!
  messages: [ChatMessage]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ChatStreamEvent {
  sessionId: String!
  type: ChatStreamEventType!
  content: String
  node: String
}

"""Type of chat stream event"""
enum ChatStreamEventType {
  TOKEN
  THINKING
  UPDATE
  DONE
  ERROR
}

type ChatStreamStart {
  sessionId: String!
  status: String!
}

type ChatResponse {
  response: String!
  sessionId: String!
}

type JobStatusObject {
  id: String!
  status: JobStatus!
  progress: Int!
  result: JSON
  error: String
  createdAt: DateTime!
  finishedAt: DateTime
}

"""Status of a background job"""
enum JobStatus {
  WAITING
  ACTIVE
  COMPLETED
  FAILED
  DELAYED
}

type JobResultObject {
  jobId: String!
  result: JSON!
}

type Query {
  hello: String!
  verifyEmail(token: String!): MessageResponse!
  me: User!
  listApiKeys: [ApiKey!]!
  getUserPosts(limit: Int): [Post!]!
  getPost(postId: String!): Post!
  getTikTokCreatorInfo: TikTokCreatorInfo!
  getCredentials(platform: String): [Credential!]!
  getConnectedAccounts: [Credential!]!
  currentTenant: Tenant!
  getMonitoredProfiles: [MonitoredProfile!]!
  getMonitoredProfile(profileId: String!): MonitoredProfile!
  getProfileTweets(profileId: String!, limit: Int, offset: Int): [Tweet!]!
  getTimelineTweets(limit: Int, offset: Int): [Tweet!]!
  getProfileStats(profileId: String!): JSON!
  analyzeTrends(topic: String, timeRange: String): JSON!
  searchTweets(query: String!, limit: Int, offset: Int): [Tweet!]!
  getInsights(limit: Float): [Insight!]!
  getUserChatSessions: [ChatSession!]!
  getChatSessionHistory(sessionId: String!): [ChatMessage!]!

  """Get status of a job by ID"""
  jobStatus(jobId: String!): JobStatusObject!

  """Get status of multiple jobs"""
  jobStatuses(jobIds: [String!]!): [JobStatusObject!]!

  """Get result of a completed job"""
  jobResult(jobId: String!): JobResultObject!

  """Get all jobs from a specific queue"""
  queueJobs(queueName: String!): [JobStatusObject!]!
  getOrganizationUsers: [User!]!
  listPendingInvitations: [UserInvitation!]!
}

type Mutation {
  register(email: String!, password: String!, firstName: String!, lastName: String!, organizationName: String!): MessageResponse!
  login(email: String!, password: String!): AuthPayload!
  requestPasswordReset(email: String!): MessageResponse!
  resetPassword(token: String!, newPassword: String!): MessageResponse!
  resendVerificationEmail: MessageResponse!
  acceptInvitation(token: String!, email: String!, firstName: String!, lastName: String!, password: String!): AuthPayload!
  createApiKey(input: CreateApiKeyInput!): CreateApiKeyResponse!
  revokeApiKey(apiKeyId: ID!): Boolean!
  updateApiKeyScopes(apiKeyId: ID!, scopes: [String!]!): ApiKey!
  createPost(input: CreatePostInput!): Post!
  updatePost(postId: String!, input: UpdatePostInput!): Post!
  deletePost(postId: String!): Boolean!
  publishPost(postId: String!): Post!
  retryPublishPost(postId: String!): Post!
  testPublish: Boolean!
  deleteCredential(credentialId: String!): Boolean!
  testCredential(credentialId: String!): Boolean!
  updateTenant(name: String!): Tenant!
  regenerateClientSecret: String!
  addMonitoredProfile(xUsername: String!): MonitoredProfile!
  removeMonitoredProfile(profileId: String!): Boolean!
  refreshProfileTweets(profileId: String!): JobIdResponse!

  """
  Generate AI insights (returns job ID - query jobStatus to check progress)
  """
  generateAIInsights(topic: String, llmProvider: String, credentialId: Int): JobIdResponse!

  """
  Generate post template (returns job ID - query jobStatus to check progress)
  """
  generatePostTemplate(insights: [String!]!, platform: String!, tone: String, llmProvider: String, credentialId: Int): JobIdResponse!

  """
  Index tweets to vector database (returns job ID - query jobStatus to check progress)
  """
  indexTweetsToVector(profileId: String!): JobIdResponse!

  """Index tweets for ALL monitored profiles (returns array of job IDs)"""
  indexAllTweetsToVector: BatchIndexResponse!
  markInsightAsRead(insightId: String!): Insight!
  reindexAllTweets: Boolean!
  createChatSession(title: String): ChatSession!
  chatWithAI(message: String!, sessionId: String, llmProvider: String, credentialId: Int): ChatResponse!
  startChatStream(message: String!, sessionId: String, llmProvider: String, credentialId: Int): ChatStreamStart!
  deleteChatSession(sessionId: String!): Boolean!

  """Retry a failed job"""
  retryJob(jobId: String!): JobStatusObject!
  inviteUser(input: InviteUserInput!): UserInvitation!
  revokeInvitation(invitationId: ID!): Boolean!
}

input CreateApiKeyInput {
  name: String!
  scopes: [String!]!
  expiresAt: String
}

input CreatePostInput {
  content: String!
  mediaUrls: [String!]
  targetPlatforms: [String!]!
  platformSpecificContent: JSON
  scheduledFor: String
  tiktokSettings: TikTokPostSettingsInput
}

input TikTokPostSettingsInput {
  privacy_level: String!
  allow_comment: Boolean!
  allow_duet: Boolean!
  allow_stitch: Boolean!
  is_brand_organic: Boolean! = false
  is_branded_content: Boolean! = false
}

input UpdatePostInput {
  content: String
  mediaUrls: [String!]
  targetPlatforms: [String!]
  platformSpecificContent: JSON
  scheduledFor: String
  tiktokSettings: TikTokPostSettingsInput
}

input InviteUserInput {
  email: String!
  role: UserRole!
}

type Subscription {
  postUpdated: Post!
  chatStream(sessionId: String!): ChatStreamEvent!
}